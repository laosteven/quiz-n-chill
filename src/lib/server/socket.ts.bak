import { Server } from 'socket.io';
import type { Server as HTTPServer } from 'http';
import { Server as SocketIOServer, type Socket } from 'socket.io';
import { gameManager } from './game-manager';

let io: SocketIOServer | null = null;

function broadcastGameState(gameId: string) {
	if (!io) return;
	const game = gameManager.getGame(gameId);
	if (game) {
		io.to(`game:${gameId}:host`).to(`game:${gameId}:players`).emit('game:state-update', game);
	}
}

export function initSocketServer(httpServer: HTTPServer) {
	if (io) return io;

	io = new SocketIOServer(httpServer, {
		cors: {
			origin: process.env.CORS_ORIGIN || '*',
			methods: ['GET', 'POST']
		}
	});

	console.log('âœ¨ Socket.IO server initialized');

	io.on('connection', (socket: Socket) => {
		console.log('Client connected:', socket.id);

		// Host joins
		socket.on('host:join', (gameId: string) => {
			socket.join(`game:${gameId}:host`);
			socket.emit('host:joined', { gameId });
			console.log(`Host joined game: ${gameId}`);
		});

		// Player joins
		socket.on('player:join', ({ gameId, playerName }: { gameId: string; playerName: string }) => {
			console.log(`Player attempting to join - Name: "${playerName}", GameID: "${gameId}"`);
			
			const result = gameManager.addPlayer(gameId, socket.id, playerName);
			if (result) {
				socket.join(`game:${gameId}:players`);
				socket.data.playerId = result.playerId;
				socket.data.gameId = gameId;
				
				socket.emit('player:joined', result);
				io!.to(`game:${gameId}:host`).emit('player:added', result.player);
				broadcastGameState(gameId);
			} else {
				console.log(`Failed to add player "${playerName}" to game "${gameId}"`);
				socket.emit('error', { message: 'Username already taken or game not in lobby' });
			}
		});		socket.on('host:start-game', (gameId: string) => {
			if (gameManager.startGame(gameId)) {
				const game = gameManager.getGame(gameId);
				io.to(`game:${gameId}:host`).to(`game:${gameId}:players`).emit('game:started', game);
				
				const question = game?.config.questions[0];
				if (question) {
					setTimeout(() => {
						if (gameManager.startAnswering(gameId)) {
							const updatedGame = gameManager.getGame(gameId);
							io.to(`game:${gameId}:host`).to(`game:${gameId}:players`).emit('game:state-update', updatedGame);
						}
					}, question.readTime * 1000);
				}
			}
		});

		socket.on('host:start-answering', (gameId: string) => {
			if (gameManager.startAnswering(gameId)) {
				const game = gameManager.getGame(gameId);
				io.to(`game:${gameId}:host`).to(`game:${gameId}:players`).emit('game:state-update', game);
			}
		});

		socket.on('player:submit-answer', ({ answerIndices }: { answerIndices: number[] }) => {
			const gameId = socket.data.gameId;
			const playerId = socket.data.playerId;
			
			if (gameId && playerId) {
				if (gameManager.submitAnswer(gameId, playerId, answerIndices)) {
					socket.emit('answer:submitted', { answerIndices });
					
					const answeredCount = gameManager.getAnsweredCount(gameId);
					const game = gameManager.getGame(gameId);
					const totalPlayers = game ? Object.keys(game.players).length : 0;
					
					io.to(`game:${gameId}:host`).to(`game:${gameId}:players`).emit('player:answered', { 
						playerId, 
						answeredCount, 
						totalPlayers 
					});

					// Auto-proceed if all players have answered and setting is enabled
					if (game && game.config.settings.autoProceedWhenAllAnswered && answeredCount === totalPlayers) {
						// Wait a short moment before proceeding
						setTimeout(() => {
							gameManager.calculateScores(gameId);
							if (gameManager.showScoreboard(gameId)) {
								const updatedGame = gameManager.getGame(gameId);
								const leaderboard = gameManager.getLeaderboard(gameId);
								io.to(`game:${gameId}:host`).to(`game:${gameId}:players`).emit('game:scoreboard', {
									game: updatedGame,
									leaderboard
								});
							}
						}, 1000);
					}
				}
			}
		});

		socket.on('host:show-scoreboard', (gameId: string) => {
			gameManager.calculateScores(gameId);
			if (gameManager.showScoreboard(gameId)) {
				const game = gameManager.getGame(gameId);
				const leaderboard = gameManager.getLeaderboard(gameId);
				io.to(`game:${gameId}:host`).to(`game:${gameId}:players`).emit('game:scoreboard', {
					game,
					leaderboard
				});
			}
		});

		socket.on('host:next-question', (gameId: string) => {
			if (gameManager.nextQuestion(gameId)) {
				const game = gameManager.getGame(gameId);
				
				// If we've reached the leaderboard phase (final results), send leaderboard data
				if (game?.phase === 'leaderboard') {
					const leaderboard = gameManager.getLeaderboard(gameId);
					io.to(`game:${gameId}:host`).to(`game:${gameId}:players`).emit('game:scoreboard', {
						game,
						leaderboard
					});
				} else {
					io.to(`game:${gameId}:host`).to(`game:${gameId}:players`).emit('game:state-update', game);
					
					if (game?.phase === 'question-reading') {
						const question = game.config.questions[game.currentQuestionIndex];
						setTimeout(() => {
							if (gameManager.startAnswering(gameId)) {
								const updatedGame = gameManager.getGame(gameId);
								io.to(`game:${gameId}:host`).to(`game:${gameId}:players`).emit('game:state-update', updatedGame);
							}
						}, question.readTime * 1000);
					}
				}
			}
		});

		socket.on('host:end-game', (gameId: string) => {
			if (gameManager.endGame(gameId)) {
				const game = gameManager.getGame(gameId);
				const leaderboard = gameManager.getLeaderboard(gameId);
				// Broadcast final state and leaderboard so UIs can transition
				io.to(`game:${gameId}:host`).to(`game:${gameId}:players`).emit('game:ended', {
					game,
					leaderboard
				});
				// Also emit a state update to set phase to 'finished' in all clients
				io.to(`game:${gameId}:host`).to(`game:${gameId}:players`).emit('game:state-update', game);
			}
		});

		socket.on('player:rename', ({ newName }: { newName: string }) => {
			const gameId = socket.data.gameId;
			const playerId = socket.data.playerId;
			
			if (gameId && playerId && newName.trim()) {
				if (gameManager.renamePlayer(gameId, playerId, newName.trim())) {
					const game = gameManager.getGame(gameId);
					io.to(`game:${gameId}:host`).to(`game:${gameId}:players`).emit('game:state-update', game);
				}
			}
		});

		socket.on('host:rename-player', ({ playerId, newName }: { playerId: string; newName: string }) => {
			const gameId = socket.data.gameId;
			
			if (!gameId) {
				// Host might not have set gameId in socket.data, try to find it from the rooms
				const rooms = Array.from(socket.rooms);
				const hostRoom = rooms.find(room => room.startsWith('game:') && room.endsWith(':host'));
				if (hostRoom) {
					const extractedGameId = hostRoom.replace('game:', '').replace(':host', '');
					if (extractedGameId && newName.trim()) {
						const oldName = gameManager.getGame(extractedGameId)?.players[playerId]?.name;
						if (gameManager.renamePlayer(extractedGameId, playerId, newName.trim())) {
							const game = gameManager.getGame(extractedGameId);
							io.to(`game:${extractedGameId}:host`).to(`game:${extractedGameId}:players`).emit('game:state-update', game);
							socket.emit('player:renamed', { playerId, oldName, newName: newName.trim() });
						}
					}
				}
			} else if (newName.trim()) {
				const oldName = gameManager.getGame(gameId)?.players[playerId]?.name;
				if (gameManager.renamePlayer(gameId, playerId, newName.trim())) {
					const game = gameManager.getGame(gameId);
					io.to(`game:${gameId}:host`).to(`game:${gameId}:players`).emit('game:state-update', game);
					socket.emit('player:renamed', { playerId, oldName, newName: newName.trim() });
				}
			}
		});

		socket.on('disconnect', () => {
			console.log('Client disconnected:', socket.id);
		});
	});

	return io;
}
